{
  "name": "Right Worker - Teacher Pipeline",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "worker/right/run",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "worker-right-run"
    },
    {
      "parameters": {
        "jsCode": "// Extract job payload\nconst inputData = $input.item.json;\nlet body = inputData.body || inputData;\nif (typeof body === 'string') {\n  try {\n    body = JSON.parse(body);\n  } catch (e) {\n    body = {};\n  }\n}\n\nconst sessionId = body.sessionId || '';\nconst teacher = body.teacher || '';\nconst coTeacher = body.coTeacher || '';\nconst role = body.role || 'renderer';\nconst sectionPayload = body.sectionPayload || {};\nconst language = body.language || 'English';\nconst turn = body.turn || 0;\n\nif (!sessionId || !teacher) {\n  throw new Error('Missing sessionId or teacher');\n}\n\nreturn {\n  json: {\n    sessionId: sessionId,\n    teacher: teacher,\n    coTeacher: coTeacher,\n    role: role,\n    sectionPayload: sectionPayload,\n    language: language,\n    turn: turn\n  }\n};"
      },
      "id": "extract-payload",
      "name": "Extract Payload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "url": "=http://localhost:8004/session/{{ $json.sessionId }}/state",
        "method": "GET",
        "options": {
          "timeout": 10000,
          "ignoreResponseCode": false
        }
      },
      "id": "get-session-state",
      "name": "Get Session State",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [650, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Validate teacher is still active and role is valid\nconst sessionState = $input.item.json;\nconst payload = $('Extract Payload').item.json;\nconst teacher = payload.teacher;\n\n// Check if teacher is in active teachers\nconst isActive = sessionState.activeTeachers && sessionState.activeTeachers.includes(teacher);\n\n// Check if teacher is current speaker or renderer\nconst isSpeaker = sessionState.speaker === teacher;\nconst isRenderer = sessionState.renderer === teacher;\nconst hasValidRole = isSpeaker || isRenderer;\n\n// Both conditions must be true\nconst isValid = isActive && hasValidRole;\n\nif (!isValid) {\n  throw new Error(`Teacher ${teacher} is not active or role is invalid. Active: ${isActive}, Speaker: ${isSpeaker}, Renderer: ${isRenderer}`);\n}\n\n// Pass through session state for next node\nreturn {\n  json: {\n    ...sessionState,\n    validated: true,\n    teacher: teacher\n  }\n};"
      },
      "id": "validate-active",
      "name": "Validate Still Active",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 300]
    },
    {
      "parameters": {
        "jsCode": "// Build prompt for Ollama\nconst payload = $('Extract Payload').item.json;\nconst teacher = payload.teacher;\nconst coTeacher = payload.coTeacher;\nconst role = payload.role;\nconst language = payload.language || 'English';\nconst sectionPayload = payload.sectionPayload || {};\n\nconst prompt = `You are ${teacher}, co-teaching with ${coTeacher}. You are currently the ${role}.\n\nIMPORTANT: The user's preferred language is ${language}. You must respond in this language.\n\nThe user is viewing: ${sectionPayload.url || 'a webpage'}\n\nVisible text on screen:\n${sectionPayload.visibleText || 'No text visible'}\n\nSelected text: ${sectionPayload.selectedText || 'None'}\n\nUser question: ${sectionPayload.userQuestion || 'None'}\n\nGenerate a short, natural response (8-12 seconds when spoken) in ${language} that:\n- References what's visible on screen\n- Speaks naturally, not like an AI\n- Ends with a handoff cue for the other teacher\n- Keeps it conversational and engaging\n- Responds in the user's preferred language\n\nResponse:`;\n\nreturn {\n  json: {\n    prompt: prompt,\n    model: 'mistral:7b',\n    stream: false,\n    options: {\n      temperature: 0.7,\n      top_p: 0.9,\n      num_predict: 150\n    }\n  }\n};"
      },
      "id": "prepare-llm",
      "name": "Prepare LLM Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 200]
    },
    {
      "parameters": {
        "jsCode": "// Prepare Ollama API request body\nconst input = $input.item.json;\n\nconst requestBody = {\n  model: input.model || 'mistral:7b',\n  prompt: input.prompt,\n  stream: false,\n  options: {\n    temperature: 0.7,\n    top_p: 0.9,\n    num_predict: 150\n  }\n};\n\nreturn {\n  json: {\n    ...input,\n    requestBody: requestBody\n  }\n};"
      },
      "id": "prepare-llm-body",
      "name": "Prepare LLM Body",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1150, 200]
    },
    {
      "parameters": {
        "url": "http://localhost:11434/api/generate",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.requestBody }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "llm-generate",
      "name": "LLM Generate",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1350, 200],
      "continueOnFail": false
    },
    {
      "parameters": {
        "jsCode": "// Extract and normalize LLM response (Ollama format)\nconst llmResponse = $input.item.json;\nlet responseText = '';\n\n// Handle Ollama API response format\nif (llmResponse.response) {\n  responseText = llmResponse.response.trim();\n} else if (llmResponse.text) {\n  responseText = llmResponse.text.trim();\n} else if (typeof llmResponse === 'string') {\n  responseText = llmResponse.trim();\n} else if (Array.isArray(llmResponse) && llmResponse.length > 0) {\n  // Handle array response (streaming format)\n  responseText = llmResponse.map(item => item.response || item.text || '').join('').trim();\n} else {\n  // Fallback: try to extract from any text field\n  responseText = JSON.stringify(llmResponse).substring(0, 200);\n}\n\n// Safety: ensure minimum length\nif (!responseText || responseText.length < 10) {\n  responseText = 'Let me continue explaining this section.';\n}\n\n// Trim to reasonable length (target ~8-12 seconds = ~20-30 words)\nconst words = responseText.split(/\\s+/).filter(w => w.length > 0);\nif (words.length > 35) {\n  responseText = words.slice(0, 35).join(' ') + '...';\n}\n\nreturn {\n  json: {\n    text: responseText,\n    teacher: $('Extract Payload').item.json.teacher,\n    sessionId: $('Extract Payload').item.json.sessionId,\n    turn: $('Extract Payload').item.json.turn\n  }\n};"
      },
      "id": "extract-response",
      "name": "Extract Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1550, 200]
    },
    {
      "parameters": {
        "jsCode": "// Map language to TTS voice\nconst language = $('Extract Payload').item.json.language || 'English';\nconst text = $('Extract Response').item.json.text;\n\n// Language to voice mapping (Piper TTS voices)\nconst languageVoices = {\n  'English': 'en_US-lessac-medium',\n  'Spanish': 'es_ES-sharvard-medium',\n  'French': 'fr_FR-siwis-medium',\n  'German': 'de_DE-thorsten-medium',\n  'Chinese (Simplified)': 'zh_CN-huayan-medium',\n  'Japanese': 'ja_JP-natsumi-medium',\n  'Korean': 'ko_KR-kyungha-medium',\n  'Portuguese': 'pt_BR-faber-medium',\n  'Italian': 'it_IT-riccardo-medium',\n  'Russian': 'ru_RU-ruslan-medium'\n};\n\nconst voice = languageVoices[language] || 'en_US-lessac-medium';\n\nreturn {\n  json: {\n    text: text,\n    voice: voice,\n    language: language\n  }\n};"
      },
      "id": "map-voice",
      "name": "Map Voice",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1550, 200]
    },
    {
      "parameters": {
        "url": "http://localhost:8001/tts",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "keypair",
        "bodyParameters": {
          "parameters": [
            {
              "name": "text",
              "value": "={{ $json.text }}"
            },
            {
              "name": "voice",
              "value": "={{ $json.voice }}"
            }
          ]
        },
        "options": {
          "timeout": 60000
        }
      },
      "id": "tts-generate",
      "name": "TTS Generate",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1850, 200],
      "continueOnFail": false
    },
    {
      "parameters": {
        "jsCode": "// Prepare data for LongCat-Video-Avatar API\nconst ttsResponse = $input.item.json;\nconst teacher = $('Extract Response').item.json.teacher;\nconst text = $('Extract Response').item.json.text;\nconst language = $('Extract Payload').item.json.language || 'English';\n\nlet audioUrl = '';\n\n// Extract audio URL from TTS response (try multiple possible fields)\nif (ttsResponse.audio_url) {\n  audioUrl = ttsResponse.audio_url;\n} else if (ttsResponse.url) {\n  audioUrl = ttsResponse.url;\n} else if (ttsResponse.audio) {\n  audioUrl = ttsResponse.audio;\n} else if (ttsResponse.file_url) {\n  audioUrl = ttsResponse.file_url;\n} else if (typeof ttsResponse === 'string') {\n  audioUrl = ttsResponse;\n} else {\n  throw new Error(`No audio URL found in TTS response. Response keys: ${Object.keys(ttsResponse).join(', ')}`);\n}\n\n// Ensure audioUrl is a full URL, not just a path\nif (audioUrl && !audioUrl.startsWith('http')) {\n  audioUrl = `http://localhost:8001${audioUrl.startsWith('/') ? '' : '/'}${audioUrl}`;\n}\n\n// Teacher-specific text prompts\nconst teacherPrompts = {\n  'teacher_a': 'A warm and approachable educator speaking naturally.',\n  'teacher_b': 'A technical expert speaking precisely.',\n  'teacher_c': 'An enthusiastic educator speaking clearly.',\n  'teacher_d': 'An innovative educator speaking energetically.',\n  'teacher_e': 'A knowledgeable educator speaking supportively.'\n};\n\nconst textPrompt = teacherPrompts[teacher] || 'A person speaking naturally';\n\nreturn {\n  json: {\n    audio_url: audioUrl,\n    avatar_id: String(teacher),\n    text_prompt: textPrompt,\n    text: text,\n    language: language,\n    sessionId: $('Extract Response').item.json.sessionId,\n    turn: $('Extract Response').item.json.turn,\n    audioUrl: audioUrl\n  }\n};"
      },
      "id": "prepare-video",
      "name": "Prepare Video",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2050, 200]
    },
    {
      "parameters": {
        "url": "http://localhost:8003/generate",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"avatar_id\": \"{{ $json.avatar_id }}\",\n  \"audio_url\": \"{{ $json.audio_url }}\",\n  \"text_prompt\": \"{{ $json.text_prompt }}\",\n  \"resolution\": \"480p\",\n  \"num_segments\": 1\n}",
        "options": {
          "timeout": 300000
        }
      },
      "id": "video-generate",
      "name": "Video Generate",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [2250, 200],
      "continueOnFail": false
    },
    {
      "parameters": {
        "jsCode": "// Format clip data for Coordinator\nconst videoResponse = $input.item.json;\nconst teacher = $('Extract Response').item.json.teacher;\nconst text = $('Extract Response').item.json.text;\nconst sessionId = $('Extract Response').item.json.sessionId;\nconst turn = $('Extract Response').item.json.turn;\n\n// Get audio URL from Prepare Video node (stored there)\nconst audioUrl = $('Prepare Video').item.json.audioUrl || $('Prepare Video').item.json.audio_url || '';\n\n// Generate clip ID\nconst clipId = `clip-${sessionId}-${teacher}-${turn}-${Date.now()}`;\n\n// Extract video URL\nlet videoUrl = '';\nlet jobId = '';\nlet status = 'processing';\n\nif (videoResponse) {\n  status = videoResponse.status || 'processing';\n  jobId = videoResponse.job_id || videoResponse.jobId || '';\n  \n  if (jobId) {\n    videoUrl = `http://localhost:8003/video/${jobId}`;\n  } else if (videoResponse.video_url) {\n    videoUrl = videoResponse.video_url;\n  } else if (videoResponse.videoUrl) {\n    videoUrl = videoResponse.videoUrl;\n  }\n}\n\n// Construct clip object\nconst clip = {\n  clipId: clipId,\n  text: text,\n  audioUrl: audioUrl,\n  videoUrl: videoUrl,\n  jobId: jobId,\n  durationMs: Math.ceil(text.split(' ').length * 0.5 * 1000), // Rough estimate\n  status: status,\n  sectionId: $('Extract Payload').item.json.sectionPayload?.sectionId || null,\n  turn: turn\n};\n\nreturn {\n  json: {\n    sessionId: sessionId,\n    teacher: teacher,\n    clip: clip\n  }\n};"
      },
      "id": "format-clip",
      "name": "Format Clip",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2450, 200]
    },
    {
      "parameters": {
        "jsCode": "// Prepare clip-ready payload\nconst input = $input.item.json;\n\n// Validate required fields\nif (!input.sessionId || !input.teacher || !input.clip) {\n  throw new Error(`Missing required fields: sessionId=${!!input.sessionId}, teacher=${!!input.teacher}, clip=${!!input.clip}`);\n}\n\nreturn {\n  json: {\n    sessionId: input.sessionId,\n    teacher: input.teacher,\n    clip: input.clip\n  }\n};"
      },
      "id": "prepare-clip-ready",
      "name": "Prepare Clip Ready",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2450, 200]
    },
    {
      "parameters": {
        "url": "http://localhost:8004/session/{{ $json.sessionId }}/clip-ready",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "post-clip-ready",
      "name": "POST Clip Ready",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [2750, 200],
      "continueOnFail": false
    },
    {
      "parameters": {
        "responseMode": "lastNode",
        "responseData": "firstItemJson",
        "options": {}
      },
      "id": "respond",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2950, 200]
    },
    {
      "parameters": {
        "jsCode": "// Error handler - format error response\nconst error = $input.first()?.error || { message: 'Unknown error' };\nconst sessionId = $('Extract Payload')?.first()?.json?.sessionId || 'unknown';\n\nreturn {\n  json: {\n    error: true,\n    message: error.message || 'Workflow execution failed',\n    sessionId: sessionId,\n    node: error.node || 'unknown',\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "id": "error-handler",
      "name": "Error Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2650, 400]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Extract Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Payload": {
      "main": [
        [
          {
            "node": "Get Session State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Session State": {
      "main": [
        [
          {
            "node": "Validate Still Active",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "error": [
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Still Active": {
      "main": [
        [
          {
            "node": "Prepare LLM Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare LLM Request": {
      "main": [
        [
          {
            "node": "Prepare LLM Body",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare LLM Body": {
      "main": [
        [
          {
            "node": "LLM Generate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM Generate": {
      "main": [
        [
          {
            "node": "Extract Response",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "error": [
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Response": {
      "main": [
        [
          {
            "node": "Map Voice",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Voice": {
      "main": [
        [
          {
            "node": "TTS Generate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "TTS Generate": {
      "main": [
        [
          {
            "node": "Prepare Video",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "error": [
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Video": {
      "main": [
        [
          {
            "node": "Video Generate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Video Generate": {
      "main": [
        [
          {
            "node": "Format Clip",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "error": [
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Clip": {
      "main": [
        [
          {
            "node": "Prepare Clip Ready",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Clip Ready": {
      "main": [
        [
          {
            "node": "POST Clip Ready",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "POST Clip Ready": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "error": [
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Handler": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": {},
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2026-01-23T00:00:00.000Z",
  "versionId": "1"
}
